# !/usr/bin/env python3

from Scoot.Connect import postgresql
from Scoot.Config import config
from sqlalchemy.orm.exc import NoResultFound
from Scoot.Utils import db
from collections import namedtuple
from Scoot.Utils import process as pr
import multiprocessing
from pathos.multiprocessing import ProcessingPool as Pool


class RecordCountValidation:

    def __init__(self, args):
        self._table_list = []
        self.result = {}



        self._conf = config.Config()

        self._meta_post_host = getattr(self._conf, 'SCOOT_META_POST_HOST')
        self._meta_post_username = getattr(self._conf, 'SCOOT_META_POST_USERNAME')
        self._meta_post_userpass = getattr(self._conf, 'SCOOT_META_POST_PASS')
        self._meta_post_port = getattr(self._conf, 'SCOOT_META_POST_PORT')
        self._meta_post_db = getattr(self._conf, 'SCOOT_META_POST_DB')
        #self._meta_post_url = getattr(self._conf, 'SCOOT_META_POST_URL')

        meta_post_url = f"postgresql://{self._meta_post_username}:{self._meta_post_userpass}@{self._meta_post_host}/{self._meta_post_db}"

        Postgresql = namedtuple('Postgresql', ['post_host',
                                               'post_username',
                                               'post_userpass',
                                               'post_port',
                                               'post_db',
                                               'post_url'])

        args = Postgresql(post_host=self._meta_post_host,
                          post_username=self._meta_post_username,
                          post_userpass=self._meta_post_userpass,
                          post_port=self._meta_post_port,
                          post_db=self._meta_post_db,
                          post_url=meta_post_url)

        self.metadata = postgresql.ConnectPostgresql1(args)


    @property
    def table_list(self):
        return self._table_list

    def table_list_clean(self):
        self._table_list = []

    def result_clean(self):
        self.result = {}

    @db.connect('rds')
    def run(self, table_list, db_instance=None):
        if not table_list:
            return

        for item in table_list:
            print(f"Getting count for {item}")
            tabresult = db_instance.session.execute(f"select count(1) from {item}")
            self.result[item] = tabresult.fetchall()


    @db.connect('redshift')
    def run_redshift(self, table_list, db_instance=None):
        if not table_list:
            return

        for item in table_list:
            print(f"Getting count for {item}")
            tabresult = db_instance.session.execute(f"select count(1) from {item}")
            self.result[item] = tabresult.fetchall()

    def getTableListfromfile(self, filename):
        with open(filename, 'r') as file:
            for line in file:
                self._table_list.append(line.strip())

    @db.connect('rds')
    def getTableListfromDB(self, exclusion_list=None, db_instance=None):
        for item in db_instance.get_table_list().fetchall():
            if exclusion_list:
                if item[0] not in exclusion_list:
                    self._table_list.append(item[0])
            else:
                self._table_list.append(item[0])
        return self._table_list

    @db.connect('redshift')
    def getTableListfromRedshift(self, exclusion_list=None, db_instance=None):
        for item in db_instance.get_table_list().fetchall():
            if exclusion_list:
                if item[0] not in exclusion_list:
                    self._table_list.append(item[0])
            else:
                self._table_list.append(item[0])
        return self._table_list

    def print(self):
        for index, value in self.result.items():
            print(f"table {index} has {value[0][0]} records")


    def save2DBfromfile(self, is_source, filename):
        with open(filename, 'r') as f:
            line = f.readlines()

        for item in line:
            index, value = item.split(',')
            if is_source:

                self.metadata.execute(f"insert into table_count_compare (database_name, tablename, record_count) values ('RDS', '{index.strip()}', '{value.strip()}')")
            else:
                self.metadata.execute(f"insert into table_count_compare (database_name, tablename, record_count) values ('Redshift', '{index.strip()}', '{value.strip()}')")

            print(f"inserted to table table_count_compare with value ('{index.strip()}', '{value.strip()}')")

        self.metadata.session.commit()

    @db.connect('redshift')
    def save2DB(self, is_source, db_instance=None):
        for index, value in self.result.items():
            if is_source:
                print(f"insert into table_count_compare (source_table, source_count) values ('{index}', '{value[0][0]}')")
                self.metadata.execute(f"insert into table_count_compare (source_table, source_count) values ('{index}', '{value[0][0]}')")
            else:
                self.metadata.execute(f"insert into table_count_compare (target_table, target_count) values ({index}, {value})")

        self.metadata.session.commit()


    def save2file(self, filename):
        with open(filename, 'w') as f:
            for index, value in self.result.items():
                f.write(f"{index}, {value[0][0]}\n")


    def savetometaDB(self, is_source):
        for index, value in self.result.items():
            if is_source:
                print(f"insert into table_count_compare (source_table, source_count) values ('{index}', '{value[0][0]}')")
                self.metadata.execute(f"insert into table_count_compare (databasename, tablename, record_count) values ('RDS', '{index}', '{value[0][0]}')")
            else:
                self.metadata.execute(f"insert into table_count_compare (databasename, tablename, record_count) values ('Redshift', '{index}', '{value[0][0]}')")

        self.metadata.session.commit()

    def targetmatch(self):
        for index, value in self.result.items():
            print(f"select id from table_compare where source_table = '{index.split('.')[-1]}'")
            try:
                tbl_id = self.metadata.execute(f"select id from table_compare where source_table = '{index.split('.')[-1]}'").first()
            except NoResultFound:
                tbl_id = []  # or however you need to handle it
            #print(tbl_id.fetchone())
            if tbl_id:
                self.metadata.execute(f"update table_compare set target_table = '{index}', target_count = '{value[0][0]}' where id = {tbl_id[0]}")

            self.metadata.session.commit()

    def __repr__(self):
        return (f"({self.__class__.__name__}")


#def getTableListfromDB1(exclusion_list=None):
#    return RecordCountValidation().getTableListfromDB(exclusion_list)


if __name__ == '__main__':
    args = db.setup_rds()
    record = RecordCountValidation(args)
    #table_list = record.getTableListfromDB(exclusion_list=['ride_updates'])
    table_list = record.getTableListfromDB(['ride_updates'])
    #run1(table_list)
    #record.run(table_list)
    #record.print()
    #record.save2file("table_list.txt")

    # record.save2DBfromfile(True, "table_list.txt")
    record.table_list_clean()
    record.result_clean()

    record.getTableListfromRedshift()
    record.run_redshift(record.table_list)
    record.save2file("table_list_target.txt")
    record.save2DBfromfile(False, "table_list_target.txt")


    exit(0)

    #pool = multiprocessing.Pool(processes=4)



    #results = [pool.apply_async(RecordCountValidation.run, table_list)]
    #pool.close()
    #for item in results:
    #    item.get()
    #f = [r.get()[0] for r in results]
    #print(f)

    #cpu_count = multiprocessing.cpu_count()
    #p = Pool(cpu_count)

    #task_list, path = ext.schedule_multi_extract("", post_url, tablename, key, 0)
    #result = p.map(record.run, table_list)
    #p.close()
    #p.join()
    # print(result)



